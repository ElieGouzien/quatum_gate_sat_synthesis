#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Implement representations of ring extensions of ℤ.

In practice, we represent only ℤ[√2, i] and ℤ[√2, √(2 + √2), i].
The classes make it easy to handle numpy arrays.

@author: Élie Gouzien
"""
import math
from typing import NamedTuple
from numbers import Integral
from itertools import chain
import warnings

import numpy as np
import sympy as sp
from sympy import ZZ, I, sqrt, expand, sympify


# TODO : rajouter de l'héritage, pour limiter les copier_coller.
#        par exemple en utilisant __slots__, et non NamedTuple.
#        faire aussi une classe générique ComplexAlgebraicNumber.

# TODO : éventuellement faire une version pour les racines 4emes de l'unité
#        mais a priori peu utile car la porte d'Hadamard n'est déjà pas
#        compatible (géré par point précédent).


def _isnull(number):
    """Test nullity, including for numpy matrices."""
    try:
        return bool(number == 0)
    except ValueError:  # Numpy array
        return np.all(number == 0)


class ReUnitRoots8Ring(NamedTuple):
    """Extension of ℤ or ℚ generated by real part of 8th roots of unit.

    Concretely, it is represented as a vector of ints (or rationnals)
    being multiples of 1 and √2 and their products.

    In operators, if not from the same class the other number is considered
    as integet (or rational). Can be used with numpy arrays as coefficients
    instead of numbers ; matrix product @ operator is supported.
    """

    # TODO: éventuellement désimplémenter la version matricielle et laisser
    #       faire numpy, en utilisant des tableaux de UnitRoots8Ring.

    int_: int = 0
    sqrt2: int = 0

    domain = ZZ.algebraic_field(sqrt(2))

    @classmethod
    def new_one(cls):
        """One."""
        return cls(int_=1)

    @classmethod
    def new_sqrt2(cls):
        """Square root of two."""
        return cls(sqrt2=1)

    @classmethod
    def from_sympy(cls, expr):
        """Generate a number ReUnitRoots8Ring from a sympy expression."""
        notint_error = ValueError("Conversion from sympy expression only "
                                  "supported from integer coefficients! "
                                  "Remove `content(expr)` before! "
                                  "Try to increase the number of gates.")
        # https://docs.sympy.org/latest/modules/polys/numberfields.html
        reste = cls.domain.to_sympy(cls.domain.from_sympy(expr))
        irrat_forms = [sqrt(2)]
        coeffs = []
        for irrat in irrat_forms:
            reste, part = reste.as_independent(irrat, as_Add=True)
            # HINT: éventuellement (re)mettre "simplify()"
            part = expand(part/irrat)
            if not part.is_integer:
                raise notint_error
            coeffs.append(int(part))
        if not reste.is_integer:
            raise notint_error
        coeffs.append(int(reste))
        return cls._make(reversed(coeffs))

    @classmethod
    def from_sympy_mat(cls, mat):
        """Generate a number from a sympy matrix."""
        res = cls._make(np.zeros(mat.shape, dtype=object) for _ in range(2))
        for coord in np.ndindex(mat.shape):
            res[0][coord], res[1][coord] = cls.from_sympy(mat[coord])
        for submat in res:
            submat.flags.writeable = False
        return res

    def to_sympy(self):
        """Convert the number to sympy."""
        res = sympify(self.int_) + sqrt(2)*sympify(self.sqrt2)
        if isinstance(
                res, sp.tensor.array.dense_ndim_array.ImmutableDenseNDimArray):
            res = sp.ImmutableDenseMatrix(res)
        return res

    def map(self, func):
        """Apply a function to each component."""
        return self.__class__._make(map(func, self))

    def __float__(self):
        """Conversion to float."""
        return self.int_ + math.sqrt(2)*self.sqrt2

    def __round__(self, ndigits=None):
        """Round, for builtin round."""
        return float(self).__round__(ndigits)

    def __str__(self):
        """Nice string representation."""
        if isinstance(self.int_, np.ndarray):
            jonction = "\n\n+"
        else:
            jonction = " + "
        res = jonction.join(str(x)+mul for x, mul in zip(self, ["", "*√2"])
                            if not _isnull(x))
        if res:
            return res
        return str(self.int_)

    def __pos__(self):
        """Positivation of itself."""
        return self

    def __neg__(self):
        """Minus itself."""
        return self._make(-x for x in self)

    def __add__(self, other):
        """Add two numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self._make(x + y for x, y in zip(self, other))
        return self._replace(int_=self.int_ + other)

    def __radd__(self, other):
        """Reversed addition, see doc of __add__()."""
        return self + other

    def __sub__(self, other):
        """Substraction."""
        return self + (-other)

    def __rsub__(self, other):
        """Right substraction."""
        return other + (-self)

    def __mul__(self, other):
        """Multiply numbers, other considered integer if different class."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1 = self
            a2, b2 = other
            return self.__class__(a1*a2 + 2*b1*b2, a1*b2 + b1*a2)
        return self._make(x*other for x in self)

    def __rmul__(self, other):
        """Right multiplication assumed commutative , see doc of __mul__()."""
        return self * other

    def __pow__(self, exponent, modulo=None):
        """Integral power of a number."""
        if not (isinstance(exponent, Integral) and modulo is None):
            return NotImplemented
        square = self
        res = self.__class__() + 1
        while exponent > 0:
            if exponent & 1:
                res *= square
            square *= square
            exponent >>= 1
        return res

    def __matmul__(self, other):
        """Matrix multiplication, when each coef is a matrix."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1 = self
            a2, b2 = other
            return self.__class__(a1@a2 + 2*b1@b2, a1@b2 + b1@a2)
        return self._make(x@other for x in self)

    def __rmatmul__(self, other):
        """Right matrix multiplication, when each coef is a matrix."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1 = self
            a2, b2 = other
            return self.__class__(a2@a1 + 2*b2@b1, b2@a1 + a2@b1)
        return self._make(x@other for x in self)

    def div_round(self, other: int):
        """Divide by an integer and round."""
        try:
            return self._make(round(x/other) for x in self)
        except TypeError:
            return self._make(np.vectorize(round)(x/other) for x in self)

    @property
    def shape(self):
        """Shape of the matrix, when it is a matrix."""
        return self.int_.shape

    def mat_getitem(self, key):
        """Subcripting, for the matrix variants."""
        return self._make(x[key] for x in self)

    @property
    def mat_indexed(self):
        """Subcripting, for the matrix variants."""
        class Proxy:
            """Proxy class to be able to use more natural slicing on it."""

            @staticmethod
            def __getitem__(key):
                return self.mat_getitem(key)
        return Proxy()


class ReUnitRoots16Ring(NamedTuple):
    """Extension of ℤ or ℚ generated by real part of 16th roots of unit.

    Concretely, it is represented as a vector of ints (or rationnals)
    being multiples of 1, √2 and sqrt(2 + √2) and their products.

    In operators, if not from the same class the other number is considered
    as integet (or rational). Can be used with numpy arrays as coefficients
    instead of numbers ; matrix product @ operator is supported.
    """

    # TODO: éventuellement désimplémenter la version matricielle et laisser
    #       faire numpy, en utilisant des tableaux de UnitRoots16Ring.

    int_: int = 0  # integer part
    sqrt2: int = 0  # √2
    sqrtbis: int = 0  # sqrt(2 + √2)
    sqrt_sqrtbis: int = 0  # √2 * sqrt(2 + √2)

    domain = ZZ.algebraic_field(sqrt(2), sqrt(2+sqrt(2)), sqrt(2-sqrt(2)))

    @classmethod
    def new_one(cls):
        """One."""
        return cls(int_=1)

    @classmethod
    def new_sqrt2(cls):
        """Square root of two."""
        return cls(sqrt2=1)

    @classmethod
    def new_sqrtbis(cls):
        """sqrt(2 + √2)."""
        return cls(sqrtbis=1)

    @classmethod
    def from_sympy(cls, expr):
        """Generate a number ReUnitRoots16Ring from a sympy expression."""
        notint_error = ValueError("Conversion from sympy expression only "
                                  "supported from integer coefficients! "
                                  "Remove `content(expr)` before!")
        # https://docs.sympy.org/latest/modules/polys/numberfields.html
        reste = cls.domain.to_sympy(cls.domain.from_sympy(expr))
        irrat_forms = [sqrt(2)*sqrt(sqrt(2)+2), sqrt(sqrt(2)+2), sqrt(2)]
        coeffs = []
        for irrat in irrat_forms:
            reste, part = reste.as_independent(irrat, as_Add=True)
            # HINT: éventuellement (re)mettre "simplify()"
            part = expand(part/irrat)
            if not part.is_integer:
                raise notint_error
            coeffs.append(int(part))
        if not reste.is_integer:
            raise notint_error
        coeffs.append(int(reste))
        return cls._make(reversed(coeffs))

    @classmethod
    def from_sympy_mat(cls, mat):
        """Generate a number from a sympy matrix."""
        res = cls._make(np.zeros(mat.shape, dtype=object) for _ in range(4))
        for coord in np.ndindex(mat.shape):
            (res[0][coord], res[1][coord],
             res[2][coord], res[3][coord]) = cls.from_sympy(mat[coord])
        for submat in res:
            submat.flags.writeable = False
        return res

    def to_sympy(self):
        """Convert the number to sympy."""
        res = (sympify(self.int_) + sqrt(2)*sympify(self.sqrt2)
               + sqrt(sqrt(2)+2)*sympify(self.sqrt_sqrtbis)
               + sqrt(2)*sqrt(sqrt(2)+2)*sympify(self.sqrt_sqrtbis))
        if isinstance(
                res, sp.tensor.array.dense_ndim_array.ImmutableDenseNDimArray):
            res = sp.ImmutableDenseMatrix(res)
        return res

    def map(self, func):
        """Apply a function to each component."""
        return self.__class__._make(map(func, self))

    def __float__(self):
        """Conversion to float."""
        return (self.int_ + math.sqrt(2)*self.sqrt2
                + math.sqrt(math.sqrt(2)+2)*self.sqrt_sqrtbis
                + math.sqrt(2)*math.sqrt(math.sqrt(2)+2)*self.sqrt_sqrtbis)

    def __round__(self, ndigits=None):
        """Round, for builtin round."""
        return float(self).__round__(ndigits)

    def __str__(self):
        """Nice string representation."""
        # return "{} + {}*√2 + {}*√[2+√2] + {}*√2√[2+√2]".format(*self)
        if isinstance(self.int_, np.ndarray):
            jonction = "\n\n+"
        else:
            jonction = " + "
        res = jonction.join(str(x)+mul for x, mul in zip(
            self, ["", "*√2", "*√[2+√2]", "*√2√[2+√2]"]) if not _isnull(x))
        if res:
            return res
        return str(self.int_)

    def __pos__(self):
        """Positivation of itself."""
        return self

    def __neg__(self):
        """Minus itself."""
        return self._make(-x for x in self)

    def __add__(self, other):
        """Add two numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self._make(x + y for x, y in zip(self, other))
        return self._replace(int_=self.int_ + other)

    def __radd__(self, other):
        """Reversed addition, see doc of __add__()."""
        return self + other

    def __sub__(self, other):
        """Substraction."""
        return self + (-other)

    def __rsub__(self, other):
        """Right substraction."""
        return other + (-self)

    def __mul__(self, other):
        """Multiply numbers, other considered integer if different class."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1, c1, d1 = self
            a2, b2, c2, d2 = other
            return self.__class__(a1*a2 + 2*b1*b2 + 2*c1*c2 + 2*c1*d2
                                  + 2*d1*c2 + 4*d1*d2,
                                  a1*b2 + b1*a2 + c1*c2 + 2*c1*d2 + 2*d1*c2
                                  + 2*d1*d2,
                                  a1*c2 + 2*b1*d2 + c1*a2 + 2*d1*b2,
                                  a1*d2 + b1*c2 + c1*b2 + d1*a2)
        return self._make(x*other for x in self)

    def __rmul__(self, other):
        """Right multiplication assumed commutative , see doc of __mul__()."""
        return self * other

    def __pow__(self, exponent, modulo=None):
        """Integral power of a number."""
        if not (isinstance(exponent, Integral) and modulo is None):
            return NotImplemented
        square = self
        res = self.__class__() + 1
        while exponent > 0:
            if exponent & 1:
                res *= square
            square *= square
            exponent >>= 1
        return res

    def __matmul__(self, other):
        """Matrix multiplication, when each coef is a matrix."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1, c1, d1 = self
            a2, b2, c2, d2 = other
            return self.__class__(a1@a2 + 2*b1@b2 + 2*c1@c2 + 2*c1@d2
                                  + 2*d1@c2 + 4*d1@d2,
                                  a1@b2 + b1@a2 + c1@c2 + 2*c1@d2 + 2*d1@c2
                                  + 2*d1@d2,
                                  a1@c2 + 2*b1@d2 + c1@a2 + 2*d1@b2,
                                  a1@d2 + b1@c2 + c1@b2 + d1@a2)
        return self._make(x@other for x in self)

    def __rmatmul__(self, other):
        """Right matrix multiplication, when each coef is a matrix."""
        # pylint: disable=C0103
        if isinstance(other, self.__class__):
            a1, b1, c1, d1 = self
            a2, b2, c2, d2 = other
            return self.__class__(a2@a1 + 2*b2@b1 + 2*c2@c1 + 2*d2@c1
                                  + 2*c2@d1 + 4*d2@d1,
                                  b2@a1 + a2@b1 + c2@c1 + 2*d2@c1 + 2*c2@d1
                                  + 2*d2@d1,
                                  c2@a1 + 2*d2@b1 + a2@c1 + 2*b2@d1,
                                  d2@a1 + c2@b1 + b2@c1 + a2@d1)
        return self._make(x@other for x in self)

    def div_round(self, other: int):
        """Divide by an integer and round."""
        try:
            return self._make(round(x/other) for x in self)
        except TypeError:
            return self._make(np.vectorize(round)(x/other) for x in self)

    @property
    def shape(self):
        """Shape of the matrix, when it is a matrix."""
        return self.int_.shape

    def mat_getitem(self, key):
        """Subcripting, for the matrix variants."""
        return self._make(x[key] for x in self)

    @property
    def mat_indexed(self):
        """Subcripting, for the matrix variants."""
        class Proxy:
            """Proxy class to be able to use more natural slicing on it."""

            @staticmethod
            def __getitem__(key):
                return self.mat_getitem(key)
        return Proxy()


class UnitRoots8Ring(NamedTuple):
    """Number from extension of ℤ or ℚ generated by the 8th roots of unit.

    Concretely, it is represented as a vector of ints (or rationnals)
    being multiples of 1, i, √2 and their products.

    In operators, if not from the same class the other number is considered
    as integet (or rational). Can be used with numpy arrays as coefficients
    instead of numbers ; matrix product @ operator is supported.
    """

    real: ReUnitRoots8Ring = ReUnitRoots8Ring()
    imag: ReUnitRoots8Ring = ReUnitRoots8Ring()

    @classmethod
    def new_one(cls):
        """Pure imaginary number."""
        return cls(real=ReUnitRoots8Ring.new_one())

    @classmethod
    def new_i(cls):
        """Pure imaginary number."""
        return cls(imag=ReUnitRoots8Ring.new_one())

    @classmethod
    def new_sqrt2(cls):
        """Square root of two."""
        return cls(real=ReUnitRoots8Ring.new_sqrt2())

    @classmethod
    def from_sympy(cls, expr):
        """Build a number from a sympy expression."""
        real, imag = expr.as_real_imag()
        return cls(ReUnitRoots8Ring.from_sympy(real),
                   ReUnitRoots8Ring.from_sympy(imag))

    @classmethod
    def from_sympy_mat(cls, expr):
        """Build a number from a sympy matrix."""
        real, imag = expr.as_real_imag()
        return cls(ReUnitRoots8Ring.from_sympy_mat(real),
                   ReUnitRoots8Ring.from_sympy_mat(imag))

    def to_sympy(self):
        """Convert the number to sympy."""
        return self.real.to_sympy() + I*self.imag.to_sympy()

    def map(self, func):
        """Apply a function to each component."""
        return self.__class__(self.real.map(func), self.imag.map(func))

    def __complex__(self):
        """As python complex number."""
        return float(self.real) + 1j*float(self.imag)

    def __str__(self):
        """Nice string representation."""
        if isinstance(self.real.int_, np.ndarray):
            jonction = "\n\n+"
        else:
            jonction = " + "
        res = jonction.join(str(x)+mul for x, mul in zip(
            self.iter_elems(), ["", "*√2", "*i", "*i√2"]) if not _isnull(x))
        if res:
            return res
        return str(self.real.int_)

    def iter_elems(self):
        """Iterate on each coefficient."""
        return chain(iter(self.real), iter(self.imag))

    def __pos__(self):
        """Positivation of itself."""
        return self

    def __neg__(self):
        """Minus itself."""
        return self._make(-self.real, -self.imag)

    def conjugate(self):
        """Complex conjugaison."""
        return self._make(self.real, -self.imag)

    def __add__(self, other):
        """Add two numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real + other.real,
                                  self.imag + other.imag)
        if isinstance(other, complex):
            warnings.warn("Direct addition of python complex number is "
                          "discouraged because not integer, use "
                          "UnitRoots8Ring.i() instead!")
            return self._replace(real=self.real + other.real,
                                 imag=self.imag + other.imag)
        return self._replace(real=self.real + other)

    def __radd__(self, other):
        """Reversed addition, see doc of __add__()."""
        return self + other

    def __sub__(self, other):
        """Substraction."""
        return self + (-other)

    def __rsub__(self, other):
        """Right substraction."""
        return other + (-self)

    def __mul__(self, other):
        """Multiply numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real*other.real - self.imag*other.imag,
                                  self.real*other.imag + self.imag*other.real)
        if isinstance(other, complex):
            warnings.warn("Python complex number considered as real in this "
                          "function, use UnitRoots8Ring.i() instead!")
            return self*self.__class__(other.real, other.imag)
        return self.__class__(self.real*other, self.imag*other)

    def __rmul__(self, other):
        """Right multiplication, assumed commutative see doc of __mul__()."""
        return self * other

    def __pow__(self, exponent, modulo=None):
        """Integral power of a number."""
        if not (isinstance(exponent, Integral) and modulo is None):
            return NotImplemented
        square = self
        res = self.__class__() + 1
        while exponent > 0:
            if exponent & 1:
                res *= square
            square *= square
            exponent >>= 1
        return res

    def __matmul__(self, other):
        """Matrix multiplication, when each real and imag are matrices."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real@other.real - self.imag@other.imag,
                                  self.real@other.imag + self.imag@other.real)
        return self.__class__(self.real@other, self.imag@other)

    def __rmatmul__(self, other):
        """Right matrix multiplication."""
        if isinstance(other, self.__class__):
            return self.__class__(other.real@self.real - other.imag@self.imag,
                                  other.imag@self.real + other.real@self.imag)
        return self.__class__(other@self.real, other@self.imag)

    def div_round(self, other: int):
        """Divide by an integer and round."""
        return self.__class__(self.real.div_round(other),
                              self.imag.div_round(other))

    @property
    def shape(self):
        """Shape of the matrix, when it is a matrix."""
        return self.real.shape

    def mat_getitem(self, key):
        """Subcripting, for the matrix variants."""
        return self._make(x.mat_getitem(key) for x in self)

    @property
    def mat_indexed(self):
        """Subcripting, for the matrix variants."""
        class Proxy:
            """Proxy class to be able to use more natural slicing on it."""

            @staticmethod
            def __getitem__(key):
                return self.mat_getitem(key)
        return Proxy()


class UnitRoots16Ring(NamedTuple):
    """Number from extension of ℤ or ℚ generated by the 16th roots of unit.

    Concretely, it is represented as a vector of ints (or rationnals)
    being multiples of 1, i, √2 and sqrt(2 + √2) and their products.

    In operators, if not from the same class the other number is considered
    as integet (or rational). Can be used with numpy arrays as coefficients
    instead of numbers ; matrix product @ operator is supported.
    """

    real: ReUnitRoots16Ring = ReUnitRoots16Ring()
    imag: ReUnitRoots16Ring = ReUnitRoots16Ring()

    @classmethod
    def new_one(cls):
        """Pure imaginary number."""
        return cls(real=ReUnitRoots16Ring.new_one())

    @classmethod
    def new_i(cls):
        """Pure imaginary number."""
        return cls(imag=ReUnitRoots16Ring.new_one())

    @classmethod
    def new_sqrt2(cls):
        """Square root of two."""
        return cls(real=ReUnitRoots16Ring.new_sqrt2())

    @classmethod
    def new_sqrtbis(cls):
        """sqrt(2 + √2)."""
        return cls(real=ReUnitRoots16Ring.new_sqrtbis())

    @classmethod
    def from_sympy(cls, expr):
        """Build a number from a sympy expression."""
        real, imag = expr.as_real_imag()
        return cls(ReUnitRoots16Ring.from_sympy(real),
                   ReUnitRoots16Ring.from_sympy(imag))

    @classmethod
    def from_sympy_mat(cls, expr):
        """Build a number from a sympy matrix."""
        real, imag = expr.as_real_imag()
        return cls(ReUnitRoots16Ring.from_sympy_mat(real),
                   ReUnitRoots16Ring.from_sympy_mat(imag))

    def to_sympy(self):
        """Convert the number to sympy."""
        return self.real.to_sympy() + I*self.imag.to_sympy()

    def map(self, func):
        """Apply a function to each component."""
        return self.__class__(self.real.map(func), self.imag.map(func))

    def __complex__(self):
        """As python complex number."""
        return float(self.real) + 1j*float(self.imag)

    def __str__(self):
        """Nice string representation."""
        if isinstance(self.real.int_, np.ndarray):
            jonction = "\n\n+"
        else:
            jonction = " + "
        res = jonction.join(str(x)+mul for x, mul in zip(
            self.iter_elems(), ["", "*√2", "*√[2+√2]", "*√2√[2+√2]", "*i",
                                "*i√2", "*i√[2+√2]", "*i√2√[2+√2]"])
                            if not _isnull(x))
        if res:
            return res
        return str(self.real.int_)

    def iter_elems(self):
        """Iterate on each coefficient."""
        return chain(iter(self.real), iter(self.imag))

    def __pos__(self):
        """Positivation of itself."""
        return self

    def __neg__(self):
        """Minus itself."""
        return self._make(-self.real, -self.imag)

    def conjugate(self):
        """Complex conjugaison."""
        return self._make(self.real, -self.imag)

    def __add__(self, other):
        """Add two numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real + other.real,
                                  self.imag + other.imag)
        if isinstance(other, complex):
            warnings.warn("Direct addition of python complex number is "
                          "discouraged because not integer, use "
                          "UnitRoots16Ring.i() instead!")
            return self._replace(real=self.real + other.real,
                                 imag=self.imag + other.imag)
        return self._replace(real=self.real + other)

    def __radd__(self, other):
        """Reversed addition, see doc of __add__()."""
        return self + other

    def __sub__(self, other):
        """Substraction."""
        return self + (-other)

    def __rsub__(self, other):
        """Right substraction."""
        return other + (-self)

    def __mul__(self, other):
        """Multiply numbers, other considered integer if different class."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real*other.real - self.imag*other.imag,
                                  self.real*other.imag + self.imag*other.real)
        if isinstance(other, complex):
            warnings.warn("Python complex number considered as real in this "
                          "function, use UnitRoots16Ring.i() instead!")
            return self*self.__class__(other.real, other.imag)
        return self.__class__(self.real*other, self.imag*other)

    def __rmul__(self, other):
        """Right multiplication, assumed commutative see doc of __mul__()."""
        return self * other

    def __pow__(self, exponent, modulo=None):
        """Integral power of a number."""
        if not (isinstance(exponent, Integral) and modulo is None):
            return NotImplemented
        square = self
        res = self.__class__() + 1
        while exponent > 0:
            if exponent & 1:
                res *= square
            square *= square
            exponent >>= 1
        return res

    def __matmul__(self, other):
        """Matrix multiplication, when each real and imag are matrices."""
        if isinstance(other, self.__class__):
            return self.__class__(self.real@other.real - self.imag@other.imag,
                                  self.real@other.imag + self.imag@other.real)
        return self.__class__(self.real@other, self.imag@other)

    def __rmatmul__(self, other):
        """Right matrix multiplication."""
        if isinstance(other, self.__class__):
            return self.__class__(other.real@self.real - other.imag@self.imag,
                                  other.imag@self.real + other.real@self.imag)
        return self.__class__(other@self.real, other@self.imag)

    def div_round(self, other: int):
        """Divide by an integer and round."""
        return self.__class__(self.real.div_round(other),
                              self.imag.div_round(other))

    @property
    def shape(self):
        """Shape of the matrix, when it is a matrix."""
        return self.real.shape

    def mat_getitem(self, key):
        """Subcripting, for the matrix variants."""
        return self._make(x.mat_getitem(key) for x in self)

    @property
    def mat_indexed(self):
        """Subcripting, for the matrix variants."""
        class Proxy:
            """Proxy class to be able to use more natural slicing on it."""

            @staticmethod
            def __getitem__(key):
                return self.mat_getitem(key)
        return Proxy()


def algeb_class(nb_phases, real=False):
    """Pick the correct class for algebraic numbers."""
    if real:
        if nb_phases == 8:
            return ReUnitRoots8Ring
        if nb_phases == 16:
            return ReUnitRoots16Ring
    else:
        if nb_phases == 8:
            return UnitRoots8Ring
        if nb_phases == 16:
            return UnitRoots16Ring
    raise ValueError("Only nb_phases == 16 ou 8 are supported!")


ALGEB_CLASSES = (ReUnitRoots8Ring, ReUnitRoots16Ring,
                 UnitRoots8Ring, UnitRoots16Ring)

# TODO: tests
